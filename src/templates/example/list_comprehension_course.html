<!--Les compréhensions de liste (list comprehension) en Python-->

<p style="margin-bottom: 1.8rem; line-height: 1.8;">La structure générale d'une compréhension de liste est la suivante :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">[nouvelle_valeur for element in iterable]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Cette syntaxe permet de créer facilement une nouvelle liste à partir d'une collection existante (iterable) en appliquant une opération à chaque élément (element) de cette collection.</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">On le verra aussi présenté sous cette forme :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">[i for i in iterable]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Nous pouvons aussi ajouter une condition pour filtrer les éléments. Par exemple, si nous voulons uniquement les carrés des nombres pairs :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">resultat = [i ** 2 for i in range(10) if i % 2 == 0]
print(resultat)
# [0, 4, 16, 36, 64]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Ici, <code style="background-color: #f5f5f5; padding: 2px 4px; border-radius: 3px; font-family: monospace; font-size: 0.9em;">if i % 2 == 0</code> sert à inclure seulement les éléments pairs dans notre nouvelle liste.</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Nous pouvons même utiliser des conditions ternaires (if...else) pour transformer les valeurs selon un test :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">resultat = [i if i % 2 == 0 else -i for i in range(10)]
print(resultat)
# [0, -1, 2, -3, 4, -5, 6, -7, 8, -9]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Cela nous permet de modifier la valeur ajoutée à la liste en fonction d'une condition, tout cela dans la même expression.</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">La compréhension de liste est donc une forme compacte mais puissante pour manipuler des collections en Python. Nous devons cependant faire attention à ne pas rendre notre code illisible en le surchargeant avec des conditions trop complexes.</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">liste = []
for n in range(20):
    if n % 2 == 0:
        liste.append(n)
print(liste)
# [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Revient à écrire :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">liste = [n for n in range(20) if n % 2 == 0]
print(liste)
# [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">On peut aussi inclure une fonction qui n'a rien à voir avec notre compréhension de liste :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">[print("Hello") for n in range(20) if n > 10]
# Hello
# Hello
# Hello
# Hello
# Hello
# Hello
# Hello
# Hello
# Hello
# [None, None, None, None, None, None, None, None, None]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Le résultat est une liste de <code style="background-color: #f5f5f5; padding: 2px 4px; border-radius: 3px; font-family: monospace; font-size: 0.9em;">None</code> car la fonction <code style="background-color: #f5f5f5; padding: 2px 4px; border-radius: 3px; font-family: monospace; font-size: 0.9em;">print()</code> ne retourne rien.</p>

<h3 style="font-size: 26px; font-weight: 700; color: #333; margin: 3rem 0 1.5rem; font-family: 'Times New Roman', serif;">Comment créer une compréhension de liste</h3>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Pour créer une compréhension de liste, par exemple si on est face au code suivant :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">liste = []
for _ in range(10):
    liste.append('Hey')

# ['Hey', 'Hey', 'Hey', 'Hey', 'Hey', 'Hey', 'Hey', 'Hey', 'Hey', 'Hey']</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">On part de notre compréhension de liste de base :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">[i for i in range(10)]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Et on remplace au fur et à mesure, ici une seule modification sera nécessaire.</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">liste = ["Hey" for _ in range(10)]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">L'utilisation de <code style="background-color: #f5f5f5; padding: 2px 4px; border-radius: 3px; font-family: monospace; font-size: 0.9em;">_</code> est une convention en Python qui indique que nous créons une variable qui n'a pas vocation à être utilisée (variable jetable).</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Une autre méthode consiste à partir de la boucle for :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">liste = []
for _ in range(10):
    if True:
        liste.append('Hey')

print(liste)
# ['Hey', 'Hey', 'Hey', 'Hey', 'Hey', 'Hey', 'Hey', 'Hey', 'Hey', 'Hey']</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">On copie/colle ce qui est à l'intérieur du append en premier.</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">['Hey' ]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Puis on copie/colle à partir de for</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">['Hey' for _ in range(10)]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Puis les conditions ternaires</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">['Hey' for _ in range(10) if True]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Et voilà le résultat :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">liste = ['Hey' for _ in range(10) if True]
print(liste)
# ['Hey', 'Hey', 'Hey', 'Hey', 'Hey', 'Hey', 'Hey', 'Hey', 'Hey', 'Hey']</code></pre>

<h3 style="font-size: 26px; font-weight: 700; color: #333; margin: 3rem 0 1.5rem; font-family: 'Times New Roman', serif;">Exemple avec le module random</h3>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">L'exemple suivant nous permet de créer une liste de 100 chiffres compris entre 0 et 10 arrondis aléatoires à l'aide du module random.</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">from random import random

liste = [round(random() * 10) for _ in range(100)]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Avec une boucle for standard :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">import random

liste = []
for _ in range(100):
    liste.append(round(random.random() * 10))
print(liste)</code></pre>

<h3 style="font-size: 26px; font-weight: 700; color: #333; margin: 3rem 0 1.5rem; font-family: 'Times New Roman', serif;">Imports de modules en Python</h3>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Commençons par observer ensemble les deux manières principales d'importer des modules en Python et comprenons les différences que cela implique dans notre manière de coder.</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Lorsque nous écrivons <code style="background-color: #f5f5f5; padding: 2px 4px; border-radius: 3px; font-family: monospace; font-size: 0.9em;">import module</code>, nous faisons entrer tout le module dans notre script, mais sans en importer directement les fonctions ou objets dans notre espace de noms. Cela signifie que nous devons toujours utiliser le nom du module comme préfixe pour accéder à ce qu'il contient. Prenons un exemple concret avec le module math :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">import math

resultat = math.sqrt(16)
print(resultat)

# 4.0</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Cette méthode est claire : chaque fois que nous voyons <code style="background-color: #f5f5f5; padding: 2px 4px; border-radius: 3px; font-family: monospace; font-size: 0.9em;">math.sqrt</code>, nous savons exactement d'où vient cette fonction. Cela réduit le risque de confusion si une autre partie de notre code définit aussi une fonction appelée sqrt. C'est donc une approche que nous privilégierons pour maintenir un code lisible et sûr.</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">L'autre manière, c'est d'écrire <code style="background-color: #f5f5f5; padding: 2px 4px; border-radius: 3px; font-family: monospace; font-size: 0.9em;">from module import objet</code>. Ici, nous importons seulement un élément précis du module et nous pouvons l'utiliser directement, sans préfixe :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">from math import sqrt

resultat = sqrt(16)
print(resultat)

# 4.0</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">C'est plus rapide à écrire, surtout si nous utilisons souvent cette fonction. Mais cela comporte aussi un risque : si un autre module ou une autre partie de notre code contient un objet du même nom, nous pourrions écraser l'un avec l'autre sans nous en rendre compte. Il faut donc rester vigilant avec cette méthode, même si elle rend notre code plus concis.</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Enfin, il existe la forme <code style="background-color: #f5f5f5; padding: 2px 4px; border-radius: 3px; font-family: monospace; font-size: 0.9em;">from module import *</code>. Cette manière d'importer tout le contenu d'un module sans préfixe est fortement déconseillée, car elle injecte tous les noms dans notre espace global sans distinction, ce qui peut rendre le code difficile à maintenir ou déboguer. Par exemple :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">from math import *

resultat = sqrt(16)
print(resultat)

# 4.0</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Même si cela fonctionne, nous perdons la trace de l'origine des fonctions utilisées, ce qui peut poser problème dans des projets plus complexes.</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">En conclusion, nous préférerons <code style="background-color: #f5f5f5; padding: 2px 4px; border-radius: 3px; font-family: monospace; font-size: 0.9em;">import module</code> pour garder un code explicite et sécurisé.</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Nous utiliserons <code style="background-color: #f5f5f5; padding: 2px 4px; border-radius: 3px; font-family: monospace; font-size: 0.9em;">from module import objet</code> lorsqu'un objet est utilisé très fréquemment, à condition de bien vérifier qu'aucun conflit de noms ne peut survenir.</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Quant à <code style="background-color: #f5f5f5; padding: 2px 4px; border-radius: 3px; font-family: monospace; font-size: 0.9em;">from module import *</code>, nous éviterons son usage autant que possible pour préserver la clarté de notre code.</p>

<h3 style="font-size: 26px; font-weight: 700; color: #333; margin: 3rem 0 1.5rem; font-family: 'Times New Roman', serif;">Exemple avec l'opérateur walrus</h3>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Une boucle for peut être utilisée tout comme une compréhension de liste, il n'y a aucune obligation.</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Voici un autre exemple :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">from random import random

liste = []

for _ in range(10):
    n = round(random() * 10)
    if n % 2 == 0:
        liste.append(n)
print(liste)

# [6, 4, 4, 8, 6, 8, 2]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Compréhension de liste :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">from random import random

liste = [n for _ in range(10) if (n := round(random() * 10)) % 2 == 0]
print(liste)

# [8, 8, 4, 4, 6]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Ici, on utilise l'opérateur walrus (<code style="background-color: #f5f5f5; padding: 2px 4px; border-radius: 3px; font-family: monospace; font-size: 0.9em;">:=</code>) introduit en Python 3.8 pour affecter une variable dans une expression.</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Cela permet de rester fidèle à notre code initial tout en profitant de la syntaxe compacte des compréhensions de liste.</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Sinon, nous aurions pu ruser en utilisant une approche différente :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">liste = [round(random() * 5) * 2 for _ in range(10)]
print(liste)

# [0, 6, 8, 10, 0, 2]</code></pre>

<h3 style="font-size: 26px; font-weight: 700; color: #333; margin: 3rem 0 1.5rem; font-family: 'Times New Roman', serif;">Compréhensions de liste déconseillées</h3>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">liste = []

for i in range(3):
    for j in range(3):
        liste.append((i, j))
print(liste)

# [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">L'équivalent en compréhension de liste serait trop verbeux et difficile à comprendre.</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">liste = [(i, j) for i in range(3) for j in range(3)]
print(liste)

# [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Cette utilisation est donc déconseillée.</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Autre exemple plus poussé :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">liste = []
for i in range(3):
    if i % 2 == 0:
        for j in 'ABC':
            liste.append((i, j))
print(liste)
# [(0, 'A'), (0, 'B'), (0, 'C'), (2, 'A'), (2, 'B'), (2, 'C')]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Revient à :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">liste = [(i, j) for i in range(3) for j in "ABC" if i % 2 == 0]
print(liste)
# [(0, 'A'), (0, 'B'), (0, 'C'), (2, 'A'), (2, 'B'), (2, 'C')]</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Dans ce type d'utilisation on mettra les opérateurs ternaires à la fin de l'expression, il peut également y en avoir plusieurs dans la même compréhension de liste.</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">liste = [(i, j) for i in range(3) for j in "ABC" if i % 2 == 0 if j != "A"]
print(liste)
# [(0, 'B'), (0, 'C'), (2, 'B'), (2, 'C')]</code></pre>

<h3 style="font-size: 26px; font-weight: 700; color: #333; margin: 3rem 0 1.5rem; font-family: 'Times New Roman', serif;">Différence entre un tuple et un set en Python</h3>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Un <strong>tuple</strong> est une séquence ordonnée d'éléments. Cela signifie que les éléments ont un ordre fixe et que cet ordre ne change pas. De plus, les tuples sont immutables, c'est-à-dire qu'une fois qu'on les a créés, on ne peut plus en modifier les éléments. Un tuple peut contenir des doublons et peut contenir tout type d'objet : nombres, chaînes de caractères, listes, autres tuples, etc.</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Regardons un exemple :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">mon_tuple = (1, 2, 3, 2)
print(mon_tuple)
print(mon_tuple[0])

# (1, 2, 3, 2)
# 1</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Ici, nous voyons que le tuple conserve l'ordre des éléments et accepte les doublons. Nous pouvons également accéder à un élément en utilisant un index.</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Passons maintenant au <strong>set</strong>. Un set, ou ensemble en français, est une collection non ordonnée et non indexée d'éléments uniques. Cela signifie que les doublons ne sont pas autorisés et que les éléments ne sont pas accessibles par un index. En revanche, un set est modifiable : on peut y ajouter ou retirer des éléments après sa création.</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Voici un exemple :</p>

<pre style="background-color: #f8f8f8; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 2rem 0; border-left: 4px solid #3273dc;"><code style="font-family: monospace; font-size: 16px;">mon_set = {1, 2, 3, 2}
print(mon_set)

# {1, 2, 3}</code></pre>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Nous remarquons que l'élément 2 en double est automatiquement supprimé, car un set ne garde qu'une seule occurrence de chaque élément. De plus, l'ordre d'affichage n'est pas garanti.</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">En résumé, si nous avons besoin d'une séquence ordonnée et immuable, nous choisissons un tuple, en revanche si nous avons besoin d'un ensemble non ordonné d'éléments uniques, nous utilisons un set.</p>

<p style="margin-bottom: 1.8rem; line-height: 1.8;">Ces différences influencent fortement le choix de l'un ou l'autre selon les besoins de notre programme.</p> 